# FreeRTOS 事件（组）【附.季度总结】



[TOC]

## 一、事件组的原理和功能

### 1、事件组的功能特点

队列、信号量等进程间通信计数有如下的特点：

![image-20240402161405057](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021614123.png)

- **一个任务通常只处理一个事件**，不能等待多个事件的发生，例如检测按键1跟按键2先后按下。如果需要处理多个事件，可能需要分解为多个任务，设置多个信号量。

- 可以有多个任务等待一个事件的发生，但是在事件发生时，**只有最高优先级的任务解除阻塞状态**，而不能同时解除多个任务的阻塞状态。（因为，有具体标志位会自动清零，即事件生效后立即失效）。

    - 是的，您的理解是正确的，尤其是在许多实时操作系统（RTOS）中，这种行为模式是针对事件标志、信号量、消息队列等同步机制的典型设计。这种机制确保在多个任务等待同一事件时，只有最高优先级的任务会首先解除阻塞状态，以响应该事件。这样做既保持了系统的响应性，也维护了任务之间的优先级顺序。

        > ### 关键点理解

        - **事件标志或信号量**：在RTOS中，事件可以通过事件标志、信号量或其他同步机制来表示。任务可以等待这些事件的发生才继续执行。
        - **优先级决定的唤醒顺序**：当事件发生（如信号量被给出）时，等待该事件的多个任务可能会变得就绪。然而，如果这些任务的优先级不同，RTOS通常会选择最高优先级的任务来唤醒和执行。这确保了最重要（优先级最高）的任务能够最先响应事件。
        - **事件自动清零**：在一些同步机制中，尤其是那些设计为事件标志的，事件发生（标志被设置）后，一旦有任务对该事件做出响应，事件标志可能会自动清零（或需要手动清零），确保事件处理逻辑的正确性。这种设计确保了事件处理的独占性，防止了事件的重复处理。

        > ### 应用场景

        这种机制非常适用于那些需要快速响应特定事件的场景，同时还有多个任务可能对同一事件感兴趣的情况。通过确保只有最高优先级的任务首先响应，系统可以有效地分配资源，同时减少响应时间。

        > ### 注意点

        - **任务饥饿**：如果高优先级任务频繁地响应事件，较低优先级的任务可能会遭遇“饥饿”现象，即它们得不到足够的机会来处理事件。这需要通过设计上的考虑来缓解，如使用优先级继承、任务轮转或其他机制。
        - **事件处理的设计**：设计事件响应逻辑时，需要考虑到事件的清零逻辑和多任务环境下的同步问题，以避免竞态条件和不一致状态。

        综上所述，您对于在事件发生时只有最高优先级的任务解除阻塞状态的理解是正确的，这是RTOS设计中用于提高系统响应性和资源分配效率的一种常见方法。

- **事件组（Event group）**是FreeRTOS中另外一种进程间通讯方法，它与队列和信号不同，具有自己的一些特点。

    - **事件组允许任务等待一个或多个事件组合**，例如按键1和按键2先后按下，或只有其中一个按键按下
    - **事件组会接触所有等待同一任务的阻塞状态，**例如任务A使用LED闪烁报警，任务B使用蜂鸣器报警，当报警事件发生时，两个任务同时接触阻塞状态，两个任务都开始运行。

> #### **事件组的这些特性使其适用于一下场景：**

- 任务等待一组事件中的某个事件后做出响应**（或运算关系）**，或一组事件完成后做出响应**（与运算关系）**
- 将事件广播给多个任务，同时解锁多个任务
- 多个任务之间的同步

### 2、事件组工作原理

需要创建事件组对象。事件组有一个内部变量存储事件标志，当**configUSE_16_BIT_TICKS**为0时，这个变量是32为的可以存储24个标志，否则是16位的存储8个标志，另外的8个位是事件组初始化的一些参数变量。**在STM32上处理器是32位的**

**事件标志只能是0或1，用单独的一个位来存储。**一个事件组的所有事件保存在一个**EventBits_t类型的变量里，****所以一个事件又称位一个 **“事件位”。**

> ### 32位的事件存储结构

![image-20240402163048666](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021630712.png)

- 31至24位是保留的，23至0位是事件位（Event Bits）
- 每一个位是一个事件标志（Event Flag），事件发生时将相应的位置1.
- 所有32位的事件组最多可以处理24个事件。

### 3、事件组的运行原理

![image-20240402163521081](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021635135.png)

- 设置事件组中的位与某个事件对应，检测到事件发时将相应的位置1，表示事件发生了。
- 可以有1个或多个任务等待事件组中的事件发生，可以是各个事件都发生**（事件位的与运算）**，或某个事件的发生（**事件位的或运算）**。
- 假设图中的任务1和任务2都以阻塞状态等待两个事件都发生，当Bit2和Bit0都被置为1后（不分先后顺序），两个任务都会被接触阻塞状态。所以，**事件组具有广播功能**。



## 二、事件组相关API

![image-20240402164735994](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021647057.png)

![image-20240402165004096](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021650154.png)

![image-20240402193037938](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021930997.png)

![image-20240402193250183](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021932230.png)

![image-20240402193321058](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021933110.png)

![image-20240402194527579](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021945644.png)

![image-20240402194737612](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021947675.png)

![image-20240402194752971](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021947031.png)

![image-20240402195048463](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021950538.png)

![image-20240402195203777](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021952837.png)

![image-20240402195230731](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021952796.png)

![image-20240402195238069](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404021952137.png)

## 三、答疑解惑

在做这个事件组练习的时候遇到了许多的问题，又系统死机的，又任务停止调度的，反正各种花样的毛病都有，但好在还是坚持下来，并且解决这个问题了，接下来就是对问题的总结与剖析，为什么会出现这种错误，以后应该如何避免这些问题。

主要还是得对问题进行分类：1：死机、2：任务停止调度、3：任务执行一半（半途而废）

针对这几个问题进行分析，我自我感觉问题并没有表面看上去这么简单，可能还有一些更深层次的坑，我刚刚没有罗列出来，但是那些坑也是在我寻找跟解决问题的一路上遇到了就顺便解决了的事情，我的意思是，这个问题最后的以解决是经验从无到有累积起来的。并不是说我解决了某个问题，其他问题都一下子全通了，这些都是互相练习的。虽然说操作系统属于中间件，但他内部其实是高度耦合的。



### 首先：第一步，弄清楚直接解决问题的问题

现在直接导致死机的问题就是：

![image-20240403165923323](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031659607.png)

系统学习后的感悟：

![image-20240403172031169](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031720465.png)

真相只有一个：

3也是与事件组出发后的时间句柄返回值，虽然说句柄不是通过这个算法的得出来的，但也差不多，只不过通过另外一种方式向我们返回了它的事件触发总值。

![image-20240403173003593](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031730763.png)

![image-20240403173154438](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031731522.png)





### 第二步：任务死机问题，一次性任务创建的一个坑

一次性任务创建起来了，在里边顺带创建了几个日常任务，然后不明所以地就死机了。

> #### 有几种可能：
>
> - 1、业务逻辑任务设计的不好，某些控制位例如前面第一步讲到的与或逻辑问题设计，因为不熟悉API而导致出错的问题。
>
> - 2、在任务的设计中没有考虑好任务优先级的编排，一次性任务的优先级低于业务逻辑任务的优先级，不过这个正常来说是不会这样的，或者说一次性任务的优先级大小跟业务逻辑任务的优先级大小相同，这个运气好的话没什么问题，运气不好就像我一样直接死机了。
>
>     - 原因就是为了简单做编排，任务句柄基本上都是采用了相同的前后缀，知识后面的句柄数字不一样，而这个数字的不一样可能是导致出现优先级翻转的一个问题，另外一种可能就是任务创建的先后时间，系统默认启动同优先级下，最后创建的一个任务进行调度，这也就间接地导致了一次性任务创建好了，但我们却迟迟见不到一次性任务删除自己，这也导致了系统内部业务逻辑的紊乱。产生死机问题也是很正常。
>
>     - ### 如何有效规避一次性任务被翻转的问题
>
>         - 策略1：确定系统内任务优先级的最高级，设置优先级为当前系统最高优先级-1的一个优先级，给到一次性任务的一个绝对调度权。（这通常是一个通用性比较高的方法）
>         - 策略2：对比其他任务，把优先级设置为最高。（这还不如策略1呢，但也不失为一种策略）



### 第三步：FreeRTOS的内核配置问题

FreeRTOS的内核配置，这个问题听起来似乎对初学者不怎么友好，但是本着计算机里没有黑魔法的一个原则，我还是直接梭哈了，记住，梭哈是种智慧。

> 在讲这个问题之前首先还是给大家投喂点鸡汤，借用浙江大学温凯老是的一句话：
>
> **学计算机一定要有一个非常强大的心理状态，计算机里的所有东西都是人做出来的，别人能做出来的，我也一定能做出来，在计算机里面，没有任何黑魔法所有的东西，只不过是我现在不知道而已，总有一天，我会把所有的事情，所有的细节搞明白的……**
>
> 一开始学习C语言指针听到温凯老师讲的这句话，一开始还是懵懂，哎。。。时间过去了这么久，两年了，一直在这条路上默默地坚持着，现在回头望去，轻舟已过万重山。想当初看似一座大山的难题，不都被跨过去了嘛，现在也是一样，现在不懂得问题只是**客观认知上的限制**，只要你肯下功夫，一切难题终会迎刃而解。

#### 下面开始讲内核配置：

说到内核配置，就需要看向我们的FreeRTOSConfig.h  顾名思义，实时操作系统配置头文件（Free Real Time Opera System Head File）。前面很多的知识中都是需要基于这点来实现的，就是对各种宏的配置，开启RTOS的各种特定功能。

就针对本期事件组来讲，他里边需要开启静态内存的配置，软件的时期的配置，还有其他个汇总宏，虽然说事件的创建它是基于动态内存来创建的，但是事件位的设置他需要用到静态内存来设置，这里边就调用到了软件定时器，它是基于静态内存来实现的。

![image-20240403180949166](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031809302.png)

![image-20240403181019304](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031810483.png)

暂且不追究实现机制，就上面这些API而言首先你得开启他们上面的一些宏这个条件，满足了这个条件后你才可以正式调用这些API实现各种机制。有些宏配置也是需要自己手写回调函数，用于处理静态内存扩展后的策略，跟软件的定时器存取任务的一个策略。

![image-20240403181256637](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031812770.png)

![image-20240403181342965](https://zdh934.oss-cn-shenzhen.aliyuncs.com/PigGo/202404031813199.png)

这些都是需要自己手动配置的，当然可以提供官网的开源社区获取到相应的解决方案，FreeRTOS的开源社区生态还是非常好的。里边提供了各种解决方案，供编程者使用。而且都是经过验证上线发布的，Release的。

官网地址：[FreeRTOS - The Free RTOS configuration constants and configuration options - FREE Open Source RTOS for small real time embedded systems](https://www.freertos.org/zh-cn-cmn-s/a00110.html)

通过一系列内核配置后，RTOS内核就可以实现更为复杂多样的操作了，有一说一，RTOS的操作机制不仅保证了系统的实时性，还给人机交互的更多智能策略的实现提供了可能，有些操作是裸机下难以实现的，在RTOS中轻松搞定。这就是RTOS的强大之处。

大家一定关心一个问题，配置不好会怎么样？轻则系统死机，重则机毁人亡，也是有可能的，哈哈。调试过程中我也是遇到了 0 wanrning  0 error 编译器的肯定，然后他直接死机了，我当时懵了，调试调不了，栈回溯也回溯不了，哈哈，还是开源社区帮了大忙。   编译正常，运行不正常这种情况说常见常见，说不常见也不常见，但对于当事者来说就是要炸了。哈哈，可以理解，因为我们有过共同的经历。



**在操作系统启动的流程，它会对各种标志位进行一个合理性的检测判断，如果检测出不合理的标志位要么就报错，要么就死机。有些报错可以通过打印log来体现，有些则一言不发，让编程者很难受，需要到处寻求资料以解决问题，运气好的话可以解决，运气不好的话，这个项目就此结束。今天这个示例记录自己寻求真理的一个心路例程，也算是基于本人学习的阶段性总结性总结，算是对自己知识的一个沉淀吧。**

> ## 愿与诸君共勉









































































